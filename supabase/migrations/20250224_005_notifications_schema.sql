-- Migration: Notifications System Schema
-- Date: 2026-02-24
-- Description: Create notifications, notification_queue, and notification_templates tables

-- ============================================================================
-- SECTION: Notifications Table
-- ============================================================================

CREATE TABLE notifications (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  type VARCHAR(50) NOT NULL,
  title VARCHAR(200) NOT NULL,
  message TEXT NOT NULL,
  action_url VARCHAR(500),
  is_read BOOLEAN DEFAULT FALSE,
  read_at TIMESTAMP NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  expires_at TIMESTAMP DEFAULT NOW() + INTERVAL '30 days'
);

COMMENT ON TABLE notifications IS 'User notifications for in-app toasts and emails';
COMMENT ON COLUMN notifications.type IS 'Type of notification: lead_assigned, mention, assignment_update';
COMMENT ON COLUMN notifications.is_read IS 'Whether user has read the notification';
COMMENT ON COLUMN notifications.expires_at IS 'When notification expires and can be deleted';

CREATE INDEX idx_notifications_user_created ON notifications(user_id, created_at DESC);
CREATE INDEX idx_notifications_unread ON notifications(user_id, is_read) WHERE is_read = FALSE;
COMMENT ON INDEX idx_notifications_user_created IS 'For querying user notifications by date';

-- Enable RLS on notifications
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- Users can see their own notifications
CREATE POLICY "user_own_notifications" ON notifications
FOR SELECT USING (user_id = auth.uid());

-- Users can mark their own notifications as read
CREATE POLICY "user_read_notifications" ON notifications
FOR UPDATE USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());

-- Only system (service role) can create notifications
CREATE POLICY "system_create_notifications" ON notifications
FOR INSERT WITH CHECK (auth.uid() IN (SELECT id FROM auth.users WHERE role = 'admin'));

-- ============================================================================
-- SECTION: Notification Queue Table
-- ============================================================================

CREATE TABLE notification_queue (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  notification_id BIGINT NOT NULL REFERENCES notifications(id) ON DELETE CASCADE,
  channel VARCHAR(20) NOT NULL CHECK (channel IN ('toast', 'email')),
  status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'failed', 'retry')),
  send_attempts INT DEFAULT 0,
  max_attempts INT DEFAULT 3,
  next_retry_at TIMESTAMP,
  error_message TEXT,
  sent_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

COMMENT ON TABLE notification_queue IS 'Queue for processing notifications to various channels';
COMMENT ON COLUMN notification_queue.channel IS 'Where to send: toast (in-app) or email';
COMMENT ON COLUMN notification_queue.status IS 'Current delivery status';

CREATE INDEX idx_notification_queue_status ON notification_queue(status, next_retry_at);
COMMENT ON INDEX idx_notification_queue_status IS 'For finding pending and failed notifications';

-- ============================================================================
-- SECTION: Notification Templates Table
-- ============================================================================

CREATE TABLE notification_templates (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  key VARCHAR(50) NOT NULL UNIQUE,
  name VARCHAR(200) NOT NULL,
  email_subject VARCHAR(200),
  email_body TEXT,
  toast_title VARCHAR(200),
  toast_message VARCHAR(500),
  created_at TIMESTAMP DEFAULT NOW()
);

COMMENT ON TABLE notification_templates IS 'Templates for notification content with variables';
COMMENT ON COLUMN notification_templates.key IS 'Unique identifier: lead_assigned, mention, assignment_update';

-- Default templates
INSERT INTO notification_templates (key, name, email_subject, email_body, toast_title, toast_message)
VALUES
  (
    'lead_assigned',
    'Lead Assigned Notification',
    'Novo lead atribuído: {lead_name}',
    '<h1>Novo Lead</h1><p>Olá {user_name},</p><p>Um novo lead foi atribuído a você:<br/><strong>{lead_name}</strong> ({company_name})<br/>Valor: ${deal_value}</p><p><a href="{action_url}">Ver lead →</a></p>',
    'Novo lead: {lead_name}',
    '{company_name} | ${deal_value} deal'
  ),
  (
    'mention',
    '@Mention Notification',
    '{mention_user} mencionou você',
    '<h1>Você foi mencionado</h1><p>Olá {user_name},</p><p><strong>{mention_user}</strong> o mencionou na nota sobre <strong>{lead_name}</strong>.</p><p><a href="{action_url}">Ver nota →</a></p>',
    '@{mention_user} mencionou você',
    'Na nota sobre {lead_name}'
  ),
  (
    'assignment_update',
    'Lead Reassigned',
    'Lead {lead_name} foi transferido',
    '<h1>Lead Transferido</h1><p>O lead <strong>{lead_name}</strong> foi transferido de {old_assignee} para {new_assignee}.</p><p><a href="{action_url}">Ver lead →</a></p>',
    'Lead transferido: {lead_name}',
    'De {old_assignee} para {new_assignee}'
  );

-- ============================================================================
-- SECTION: Stored Procedure - Create Notification
-- ============================================================================

CREATE OR REPLACE FUNCTION create_notification(
  p_user_id UUID,
  p_type VARCHAR,
  p_title VARCHAR,
  p_message TEXT,
  p_action_url VARCHAR DEFAULT NULL
)
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_notification_id BIGINT;
BEGIN
  INSERT INTO notifications (user_id, type, title, message, action_url)
  VALUES (p_user_id, p_type, p_title, p_message, p_action_url)
  RETURNING id INTO v_notification_id;

  -- Queue for both toast and email
  INSERT INTO notification_queue (notification_id, channel, status)
  VALUES
    (v_notification_id, 'toast', 'pending'),
    (v_notification_id, 'email', 'pending');

  RETURN v_notification_id;
END;
$$;

COMMENT ON FUNCTION create_notification IS 'Create notification and queue it for delivery';

-- ============================================================================
-- SECTION: Stored Procedure - Mark as Read
-- ============================================================================

CREATE OR REPLACE FUNCTION mark_notification_read(p_notification_id BIGINT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE notifications
  SET is_read = TRUE, read_at = NOW()
  WHERE id = p_notification_id AND user_id = auth.uid();
END;
$$;

COMMENT ON FUNCTION mark_notification_read IS 'Mark notification as read by current user';

-- ============================================================================
-- SECTION: Trigger - Clean Up Expired Notifications (Nightly)
-- ============================================================================

CREATE OR REPLACE FUNCTION cleanup_expired_notifications()
RETURNS TABLE(deleted_count INT)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_deleted INT;
BEGIN
  DELETE FROM notifications
  WHERE expires_at < NOW() AND deleted_at IS NULL;

  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  RETURN QUERY SELECT v_deleted;
END;
$$;

COMMENT ON FUNCTION cleanup_expired_notifications IS 'Delete expired notifications (run nightly via cron)';

-- ============================================================================
-- SECTION: ROLLBACK PROCEDURE
-- ============================================================================

-- To rollback this migration, run:
-- DROP FUNCTION cleanup_expired_notifications();
-- DROP FUNCTION mark_notification_read(BIGINT);
-- DROP FUNCTION create_notification(UUID, VARCHAR, VARCHAR, TEXT, VARCHAR);
-- DROP TABLE notification_templates;
-- DROP TABLE notification_queue;
-- DROP TABLE notifications;
